# 何をやったらいいの？

課題挑戦時(2021/6)における理解をまとめた。  


## 何をやったらいいの？

SIGUSR1とSIGUSR2、この2つだけでデータの送受信ができるような CLIENT と SERVER を作ればいい。  


## 何をやったらいいのかはわかったけど、具体的に何をやったらいいの…？

何をやったらいいかはわかったけど、具体的にどうしたらいいのか意味が分からん…。最初はこんな感じで固まるんじゃないだろうか。だけど落ち着いて考えたら気づくはず。コンピューターには2種類で表現できるものがあると。それを使おう。  
具体的には、送りたい文字列 をビットに変換して、1ビットずつ CLIENT から SERVER にデータを送信すればいい。 


## 送りたい文字列をどうやってビットに変換するの？

`int32_t型` のビット配列は、こうなっている。  
(int型は環境によってビット数が異なるので、32ビットに固定した。)  
```
00000000000000000000000000000000
```

具体的に考えてみよう。  
`char型` の 'a'(ascii==97) を `int32_t型` に変換した場合のビット配列は、こうなっている。  
```
00000000000000000000000001100001
```

で、例えば、一番右のビットを取りたい場合、どうすればいいか？ビット演算で取ることができる。  

- ビットのONを取りたい場合  
	上は'a'(ascii==97) のビット配列、下は1のビット配列。  
	```
	00000000000000000000000001100001
	00000000000000000000000000000001
	```
	この2つでビット演算 `&` を行うと、1が返ってくる。  
	`&` はどちらも1の時に1を返すから、どちらも1である一番右のビットだけが1となる。  
	それを`int32_t型`(`int型`でも可)で解釈すると、1となる。  
	```
	00000000000000000000000000000001
	```

- ビットのOFFを取りたい場合  
	上は'a'(ascii==97) のビット配列をビット演算 `>>` で1桁右にシフトしたもの、下は1のビット配列。  
	```
	00000000000000000000000000110000
	00000000000000000000000000000001
	```
	この2つでビット演算の `&` を行うと、0が返ってくる。  
	`&` はどちらも1の時に1を返すが、すべて該当しないので、すべてのビットが0となる。  
	それを`int32_t型`(`int型`でも可)で解釈すると、0となる。  
	```
	00000000000000000000000000000000
	```

この処理を、送りたいビット数だけループで繰り返せばいい。  
例えば8ビット送りたい場合、こんな感じになる。  
- ビット配列を 7ビット 右シフトして、右から 8ビットめ を取って、送る。  
- ビット配列を 6ビット 右シフトして、右から 7ビットめ を取って、送る。  
	：  
	：  
- ビット配列を 1ビット 右シフトして、右から 2ビットめ を取って、送る。  
- ビット配列を 0ビット 右シフトして、右から 1ビットめ を取って、送る。  


## 変換したビットをどうやって送ったらいいの？

CLIENT側 から SERVER側 へ送信するには signal を使う。  
具体的には、`SIGUSR1` と `SIGUSR2` をビットの ON / OFF に見立てて、CLIENT側から送信してやればいい。  
signal を送るには `kill` 関数を使う。第1引数には 送りたい相手のProcessID、第2引数には 送りたいシグナル、をセットする。  
```c
kill(server_process_id, signal_number);
```


## 送られたシグナルをどうやって受け取ったらいいの？

CLIENT側 から SERVER側 へ送信された signal を受信するには `signal` 関数を使う。第1引数には 受け取りたいシグナル、第2引数には シグナルを受け取った時の処理への関数ポインタ、をセットする。  
```c
static void	handle_signal(int signal)
{
	g_receive_signal = signal;
}

void	set_signal(void)
{
	signal(SIGUSR1, &handle_signal);
	signal(SIGUSR2, &handle_signal);
}
```


## 文字列を一方的に送りつけたけど、最後の文字がどれか分からなくない？

終了を通知するASCII文字がある。EOT(ascii==0x4)だ。それを文字列の最後につけて送信すると、受信側で判別することができる。  


## 文字列を一方的に送りつけたけど、受け取れたか分からなくない？

なら、受信確認システムを追加しよう。  
SERVER側 でビット(シグナル)を受け取って処理が完了したら、CLIENT側 に対して「受け取れた！」というシグナル(一般的にACKと呼ばれるもの)を送って、それを CLIENT側 で受け取れたら、次のビットを送る。これを最後まで繰り返せば、確実に送信することができる。  
ただ、CLIENT側 にシグナルを送るためには CLIENT の ProcessID が必要になるので、文字列を送る前にそれを送る処理を追加する必要がある。  

| CLIENT |  | SERVER |  
|:-:|:-:|:-:|  
|  | 通信開始 |  |
| CLIENT の ProcessID のビットを送信 | → |  |
|  |  | 全ビット 受信完了 |
|  | ← | 受信完了の ACK を送信 |
| ACK 受信完了 |  |  |
| Message のビットを送信 | → |  |
|  |  | 1ビット 受信完了 |
|  | ← | 受信完了の ACK を送信 |
| ACK 受信完了 |  |  |
|  | ： |  |
|  | 以下繰り返し |  |
|  | ： |  |
| Message の最終ビットを送信 | → |  |
|  |  | 最終ビット 受信完了 |
|  | ← | 受信完了の ACK を送信 |
| ACK 受信完了 |  |  |
| EOT のビットを送信 | → |  |
|  |  | 1ビット 受信完了 |
|  | ← | 受信完了の ACK を送信 |
| ACK 受信完了 |  |  |
|  | ： |  |
|  | 以下繰り返し |  |
|  | ： |  |
| EOT の最終ビットを送信 | → |  |
|  |  | 最終ビット 受信完了 |
|  | ← | 受信完了の ACK を送信 |
| ACK 受信完了 |  |  |
|  | 通信終了 |  |


## Unicode文字ってどうやって送ればいいの？

特に何もしなくても、Unicode文字 だろうが何だろうが、問題なく送信できる。  
CLIENT側 の文字列のビットをそのまま送信し、SERVER側 でそれを受信して、そのまま再現しているだけなので、同じものになって当然。  
ただし、`char型` で1文字(8ビット)受け取るたびに出力してしまうと、Unicode文字になる前に出力されるので失敗する。文字列を全部溜め込んでから出力すると成功する。  

