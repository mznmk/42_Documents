# 実装内容について

未提出なので、間違いあるかもしれません。  


## Repository

[public](https://github.com/mznmk/CPP_Module_01) ←未提出  


## Exercise 00: BraiiiiiiinnnzzzZ

### 課題解釈・実装方針

Zombie クラスを作成し、それを使って次の２つの関数を実装します。  
```
Zombie* newZombie( std::string name );
void randomChump( std::string name );
```
次の記述から、「メモリの静的・動的確保、コンストラクター・デストラクターの働きを学習する」というのがテーマだと考えました。  
```
さて、実際のところ、この演習のポイントは何でしょうか？どのような場合にスタックやヒープにゾンビを割り当てるのが良いかを判断する必要があります。
ゾンビは不要になったら破壊しなければなりません。デストラクタは、デバッグのためにゾンビの名前をメッセージとして表示しなければなりません。
```

### 実装内容

Zombie.cpp/Zombie.hpp  
Zombie クラスです。コンストラクターの引数に名前を渡し、オブジェクト生成時に名前を設定しています。  

newZombie.cpp  
単体のゾンビを生成します。関数内でメモリを動的確保し、メモリのポインタを返しています。  

randomChump.cpp  
関数内でメモリを動的確保し、メッセージを発し、メモリを解放しました。  

main.cpp  
Zombie クラス・newZombie() 関数・randomChump() 関数で単体のゾンビを６匹生成し、「メモリの静的・動的確保、コンストラクター・デストラクターの働き」の流れをメッセージで可視化しました。  

### 注意点

delete でちゃんとメモリーを開放すること。  
コンパイルのフラグに -g -fsanitaize=leak をつけてチェックするとよいです。  

### 気づき

今更なのですが、Makefile で ifdef を使って -g -fsanitize=leak をつけたり外したりできることを知りました。  


## Exercise 01: Moar brainz!

### 課題解釈・実装方針

ゾンビの群れを生成する関数を実装します。ex00との違いは、まとめて一度に複数匹作成させるところです。    
```cpp
Zombie*	zombieHorde( int N, std::string name );
``` 
オブジェクトの動的配列を理解するのがテーマだと考えました。  

### 実装内容

Zombie.cpp/Zombie.hpp  
Zombie クラスです。ex00のものを流用しています。  
コンストラクター（引数なし）を追加し、オーバーロードさせています。名前はsetterでもセットできるように変更しました。    

zombieHorde.cpp  
ソンビの群れを生成します。関数内でメモリを動的確保し、メモリのポインタを返しています。  
メモリ確保に失敗した場合、std::nothrow を使って 例外を投げずにNULLを返しています。  

main.cpp  
zombieHorde() 関数でゾンビの群れを生成し「メモリの動的確保、コンストラクター・デストラクターの働き」の流れをメッセージで可視化しました。  

### 注意点

1. delete と delete[] の違いに注意が必要です。  
	delete は先頭要素のデストラクターしか呼びませんが、delete[] は全要素のデストラクターを呼びます。ちゃんとdelete[] で開放する必要があります。  
	※ delete だと、こんなエラーが出ました。  
	```
	munmap_chunk(): invalid pointer
	```
2. new でメモリを確保できなかった場合、std::bad_allocの例外を投げますが、std::nothrowを使用した場合、失敗したときに例外を投げずにNULLが返ります。  

### 気づき

c++=98 では std::to_string は使えませんが、std::string の変数に char* を格納できると知りました。main() で使っています。  


## Exercise 02: HI THIS IS BRAIN

### 課題解釈・実装方針

これらのメモリアドレスと  
- 文字列変数のメモリアドレス。  
- stringPTR が保持するメモリアドレス。  
- stringREFが保持するメモリアドレス。  

その値を確認することで、  
- 文字列変数の値。  
- stringPTR が指す値。  
- stringREFが指す値

C++で新たに登場した参照を理解するのが目的です。  

### 実装内容

main.cpp  
上の内容をそのまま実装しただけです。  

### 注意点

特になし。  

### 気づき

参照は、元の変数に違うラベルを貼る感覚に近い？  


## Exercise 03: Unnecessary violence

### 課題解釈・実装方針

問題分から Weaponクラスの仕様がわかるので、まず大枠を実装します。  
テストケース main() が与えられているので、それに沿った形でHumanA HumanBを実装していきます。  

### 実装内容

Weapon.cpp/Weapon.hpp  
コンストラクターで初期装備をセットしています。  
setter/getterで武器のset/getができます。  

HumanA.cpp/HumanA.hpp  
コンストラクターで名前・武器をセットするという仕様です。  
ですから、攻撃する時点で武器がないということはありません。  

HumanB.cpp/HumanB.hpp  
コンストラクターで名前だけをセットするという仕様です。  
ですから、攻撃する時点で武器がない可能性があります。この場合の挙動は未定義なので、泣きながら素手で攻撃させることにしました。  

main.cpp  
問題分で与えられている テストケースです。  
コーナーケースとして、HumanB が 武器を割り当てられる前に攻撃するパターンも追加してあります。  

### 注意点

1. HumanA の Weapon はコンストラクターで初期化するため、privateメンバー _weapon は参照型で宣言しておいて、参照でコンストラクターに渡せば初期化できます。  
参照は宣言時に代入しないといけないので、こういう形をとりました。  
	```cpp
	HumanA::HumanA(std::string name, Weapon &weapon): _name(name), _weapon(weapon)
	{
	}
	```
2. HumanB の Weapon はコンストラクターで初期化しないため、privateメンバー _weapon は参照型で宣言できません（参照型は宣言と同時に初期化しないといけないため）。仕方ないのでポインタ型で宣言しておいて、NULLを割り当てておきます。武器を割り当てる前に攻撃することが考えられるため、対策しておく必要があります。    

### 気づき

getType() を const reference で返してる理由は…？ コピーコストの削減のため…？ const にしてるのは書き換え防止のためです。    
privateメンバーを Weapon::_type ではなく、this->_type と書いても、_type と書いても大丈夫だと知りました。  


## Exercise 04: Sed is for losers

### 課題解釈・実装方針

置換したいファイルを読み込み、中身を置換して、結果を別のファイルに書き出します。  

### 実装内容

Replace.cpp/Replace.hpp  
filename, s1, s2 の設定漏れがないよう、コンストラクターに参照でパラメーターを渡しています。  
処理の流れは次の通りです。  
1. 置換結果を貯め込むストリームを用意しておきます。  
2. 読み出し用として置換前のファイル開き、1行ずつ読み込みます。読み込んだ行を置換し、置換結果のストリームに流し込みます。これをEOFまで繰り返します。置換処理に際して、無限ループにならないように注意します。  
3. 置換処理完了後、書き込み用としてファイルを開き、ファイルに流し込みます。  

main.cpp  
class Replace を使って置換しているだけです。  

### 注意点

std::getline で1行ずつ読み込み、置換して、1行ずつ書き込みますが、この時に注意が必要です。"\n" と std::endl には大きな違いがあります。std::endl は 改行＋fflush なので、毎行実行した場合、fflushの分だけ遅くなります。最後の1回だけfflushすれば十分です。  

文字列を置換する際、_s1 を探すのに find を使いますが、いろいろ注意点があります。  
1. マッチするのが先頭だけなので、全てを置換するためには、マッチしなくなるまでループを回す必要があります。  
2. _s1 == "" のとき find は0 を返します。これは0文字目でのマッチした場合と同じ結果であって違いが判断がつきませんし、マッチしなくなるまでループを回そうとしても無限に0を返し続けるため、無限ループになってしまいます…。  
なお、if (_s1 == "") では 空文字列を判定できませんでした。if (_s1.empty()) にしないとだめなようです。
3. _s1 と _s2 が同じ場合は置換する必要がないですが、マッチしなくなるまでループを回そうとすると、無限に置換を続けてしまいます…。

### 気づき

とりあえず std::endl すればよいというものではない…と知りました。  


## Exercise 05: Harl 2.0

### 課題解釈・実装方針

log level に応じて、メッセージを表示します。問題文に次のような記述があることから、  
```
この演習の目標は、メンバ関数へのポインタを使用することです。これは提案ではありません。Harl は if/else if/else の森を使わずに文句を言わなければならないのです。それは二度考えません! 
```
これらの関数を関数ポインターを使って呼び出します。  
```cpp
void debug( void );
void info( void );
void warning( void );
void error( void );
```

### 実装内容

Harl.cpp/Harl.hpp  
プライベート関数４個の実装については、問題文通りで、特に難しいところはなかったです。  
```cpp
void complain( std::string level );
```
レベルの文字列（４種類）を次のような感じで配列として持ち、それとプライベート関数を関数ポインターでリンクさせました。  
```cpp
std::string levels[] = {
	"DEBUG", "INFO", "WARNING", "ERROR"
};
```

main.cpp  
Log Level に "DEBUG","INFO","WARNING","ERROR" をランダムで設定し、10回実行するように実装しました。  

### 注意点

C言語の関数ポインターと違い、C++の関数ポインターには嵌まりどころがいっぱいありました。次のリンクが参考になりました。  
メンバ関数ポインタ天国  
http://www7b.biglobe.ne.jp/~robe/cpphtml/html03/cpp03057.html  

### 気づき

Makefile に テストコマンドを仕込んで、`make test` で実行するとき、-@ をつけるとエラーを無視してくれるので、処理が止まらずに済みます。   
```
-@./harl DEBug
```
shでテストを書いて実行するとき、-x をつけると実行コマンドを表示してくれるので便利です。  
```sh
sh -x ./test.sh
```


## Exercise 06: Harl filter

### 課題解釈・実装方針

ベースは Exercise 05: Harl 2.0 と同じです。違いは、指定したLevel以上のログを全部表示するところのみです。  
以下の記述から、表示するかしないかのスイッチをつくり、不必要なところをOFFにしていけばいいとわかります。  
```
Harlに対処する方法はいくつかありますが、最も効果的な方法の1つはSWITCH OFFすることです。  
```

### 実装内容

Harl.cpp/Harl.hpp  

表示するかしないかのスイッチを以下のような感じで初期設定します。指定したLogLevelに到達する寸前までfalseにしていくと、スイッチの設定ができます。それに基づいて、プライベート関数を実行させました。  
```cpp
bool filter[] = {
	true, true, true, true
};
```

main.cpp  
引数でLogLevelを受け取り、それを class Harl に渡して実行しているだけです。   

